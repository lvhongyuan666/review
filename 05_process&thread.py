'''
系统编程: 进程、线程
'''
'''
多任务；操作系统可以同时运行多个任务
单核的cup也可以执行多任务：操作系统（os）轮流让各个任务交替执行，因为cup的运行速度实在太快了，各个任务切换的速度快，这样反复执行，看上去就像在同事执行

真正并行的多任务只能在多核cpu上实现
但是，由于任务数量远远多于cup核心数量，操作系统也会自动把很多任务轮流调度到每个核心上执行
'''


'''
进程：进程是系统分配资源的最小单位
程序在运行时需要分配内存去运行  ---内存里包含：代码、变量、计数器等

几个概念：
①孤儿进程：子进程还未没有运行完成、父进程就结束运行退出，留下的子进程就是孤儿进程
②僵尸进程：子进程运行完成，但是父进程一直没有进行回收，此时的子进程实际并没有退出，仍然占用这系统资源，这样的子进程成为僵尸进程


多进程修改全局变量：每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响

multiprocessing模块--多进程模块
multiprocessing模块提供了一个Process类来代表一个进程对象


进程池
如果需要创建多个进程的时候，可以使用multiprocessing模块提供的Pool方法来创建多个进程

进程间通讯 Queue
使用multiprocessing模块的Queue类实现多进程之间的数据传递，Queue本身是一个消息列队程序

'''
from multiprocessing import Queue, Process
# q = Queue(3)  # 初始化一个Queue对象，括号中的数字表示最多可接受的消息数量
# q.put('消息1')  # 放入消息
# q.get()   # 读数据

'''

线程：

线程是进程的一个实体，是cpu进行调度的基本单位
它是比进程更小的能独立运行的基本单元

threading模块的Thread类

在多线程开发中，全局变量是多个线程都共享的数据，而局部变量等是各自线程的，是非共享的
'''

'''
进程和线程的区别：
①一个程序至少有一个进程，一个进程至少有一个线程
②线程的划分尺度小于进程（资源比进程少），使得多线程程序的并发性高
③进程在执行过程中拥有独立的内存单元，而多个线程内存共享，从而极大提高了程序的运行效率
④线程不能够独立执行，必须依存在进程中
'''

'''
进程和线程的优缺点
进程：
优点：进程里面的资源是独享的，多个进程在操作数据时，彼此不会产生影响
缺点：因为进程里面的资源是独享的，涉及到一个完整的内存空间，操作系统在切换进程时，切换开销比较大

线程：
优点：线程资源划分小，操作系统切换线程开销小，效率高
缺点：线程是属于进程内部的，同一进程内的不同线程操作的都是同一份资源，修改变量的时候会互相影响

'''

#
# import time
# import threading
# def saySorry():
#
#     print('亲爱的，我错了')
#
#
# if __name__ == '__main__':
#     start_time = time.time()
#     for i in range(10):
#         t = threading.Thread(target=saySorry)
#
#         t.start()
#     end_time = time.time()
#     print(end_time - start_time)

'''
同步：多任务，多个任务在执行的时候要求有先后顺序，必须一个先执行完成后，另一个才能执行，只有一条运行主线
异步：多任务，多个任务的执行没有先后顺序，可以同时运行，执行的先后顺序不会有影响，存在多条运行主线


阻塞： 从调用者的角度出发，如果调用的时候被卡住，不能继续向下运行，需要等待，就是阻塞
非阻塞：从调用者的角度出发，如果在调用的时候，没有被卡住，能够继续向下运行，就是非阻塞

线程安全：
在多线程的环境下，多个线程共享进程内的资源，能够保证共享的数据能够自由的存取，但是同一时刻只能有一个线程进行存取
多线程下，解决资源竞争的办法是加锁，来保证存取操作的唯一性

多个线程对同一资源的访问，对数据造成破坏，使得结果不可预期，这种现象叫做线程不安全
对于该问题，可以使用线程同步来解决--互斥锁

互斥锁为资源引入一个状态：锁定/非锁定
当某个线程修改共享数据时，先将其锁定，此时的资源状态为锁定，其他线程不能修改，直到该线程释放资源，将状态变成非锁定，其他线程才能再次锁定该资源
互斥锁保证了每次只有一个线程进行修改操作，从而保险多线程下数据的正确性
'''

'''
threading模块中定义了Lock类 ，可以方便的处理锁定

'''
import threading
# 创建锁
mutex = threading.Lock()
# 锁定
mutex.acquire()
#----------执行任务
# 释放
mutex.release()a
'''
上锁解锁过程
当一个线程调用acquire（）方法获得锁时，锁就进入locked状态

每次只有一个线程可以获得锁，如果此时，另一个线程试图获得锁，该线程就会进入阻塞状态，直到拥有锁的线程release()释放锁后
线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行状态

锁的好处：
确保了某段关键代码只能由一个线程从头到尾完整的执行
坏处：
①阻止了多线程的并发执行，包含锁的这段代码只能以单线程的模式运行，效率就大大的降低；
②由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，会造成死锁

'''

'''
死锁：
在多线程中，因争夺资源而造成的相互等待的状态
避免死锁：添加超时时间
'''